from os import system
from .postgresql_orm_base import *
from .postgresql_utilities import _Session

def return_postgresqlQueryFromSQLAlchemyQuery(query_I):
    '''return a string representation of the actual postgresql query
    generated by SQLAlchemy
    INPUT:
    query_I = SQLAlchemy query object
    OUTPUT;
    query_O = string query
    '''
    query_O = str(query_I.statement.compile(dialect=postgresql.dialect()));
    #print(str(query_I.statement.compile(dialect=postgresql.dialect())));
    return query_O;

class postgresql_orm():
    def __init__(self):
        self.engine = None;
        self.Session = None;

    def make_engineFromSettings(self,settings_I={}):
        '''make the database engine
        INPUT:
        settings_I = string dict, {settings name:settings value}
        '''
        engine = create_engine("postgresql://%s:%s@%s/%s" %
            (settings_I['user'], settings_I['password'], settings_I['host'], settings_I['database']))
        self.engine = engine;
        return engine;

    def make_engine(self,database_I='sbaas01',user_I='guest',password_I='guest',host_I="localhost:5432"):
        '''make the database engine'''
        engine = create_engine("postgresql://%s:%s@%s/%s" %
            (user_I, password_I, host_I, database_I))
        self.engine = engine;
        return engine;

    def make_defaultEngine(self):
        '''return default database engine'''
        engine = create_engine("postgres://postgres@/postgres");
        self.engine = engine;
        return engine;

    def make_connectionFromSettings(self,
            settings_I={}):
        '''return connection to the database
        INPUT (option1):
        settings_I
        '''
        try:
            engine = self.make_engineFromSettings(settings_I);
            conn = engine.connect();
            conn.execute("commit");
            return conn;
        except SQLAlchemyError as e:
            print(e);
            exit(-1);

    def make_connection(self,
            database_I='postgres',user_I='postgres',password_I='18dglass',host_I="localhost:5432"):
        '''return connection to the database
        INPUT (option2):
        database_I
        user_I
        password_I
        host_I
        '''
        try:
            engine = self.make_engine(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
            conn = engine.connect();
            conn.execute("commit");
            return conn;
        except SQLAlchemyError as e:
            print(e);
            exit(-1);

    def create_newDatabaseAndUser(self,
            database_I='postgres',user_I='postgres',password_I='18dglass',host_I="localhost:5432",
            database_O='sbaas01',user_O='guest',password_O='guest',privileges_O=['ALL PRIVILEGES'],tables_O=['ALL TABLES'],schema_O='public'):
        '''create a new database and user
        INPUT: settings to connect to an exiting database
        database_I
        user_I
        password_I
        host_I
        OUTPUT: settings for the new database and user
        database_O
        user_O
        password_O
        privileges_O
        tables_O
        schema_O'''
        try:
            conn = self.make_connection(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
            self.create_database(conn,database_O);
            self.create_user(conn,user_O,password_O,privileges_O,tables_O,schema_O);
            conn.close();
        except SQLAlchemyError as e:
            print(e);
            exit(-1);
    
    def create_database(self,conn,database_I='sbaas'):
        """create a new database"""
        cmd = 'CREATE DATABASE "%s"' %(database_I);
        try:
            conn.execute(cmd);
        except SQLAlchemyError as e:
            print(e);
            #conn.rollback();

    def drop_database(self,conn,database_I='sbaas'):
        """drop a database"""
        cmd = 'DROP DATABASE IF EXISTS "%s"' %(database_I);
        try:
            conn.execute(cmd);
            conn.execute("commit");
        except SQLAlchemyError as e:
            print(e);

    def drop_user(self,conn,user_I):
        """drop a user"""
        cmd = 'DROP USER IF EXISTS "%s"' %(user_I);
        try:
            conn.execute(cmd);
            conn.execute("commit");
        except SQLAlchemyError as e:
            print(e);

    def create_user(self,conn,user_I='guest',password_I='guest',privileges_I=['SELECT'],tables_I=['ALL TABLES'],schema_I='public'):
        '''create a new user
        INPUT:
        user_I = username
        password_I = password
        privileges_I = list of priveleges (e.g., ['SELECT','UPDATE','DELETE','INSERT']
        tables_I = list of tables'''

        try:
            privileges = ', '.join(privileges_I);
            tables = ', '.join(tables_I);
            cmd = 'CREATE USER "%s" ' %(user_I);
            cmd += "WITH PASSWORD '%s'" %(password_I);
            conn.execute(cmd);
            conn.execute("commit");
            cmd = 'GRANT %s ON %s IN SCHEMA %s TO "%s"' %(privileges,tables,schema_I,user_I);
            conn.execute(cmd);
            conn.execute("commit");
        except SQLAlchemyError as e:
            print(e);
            #conn.rollback();

    def set_sessionFromSettings(self,settings_I):
        '''set a session object ,database_I='sbaas01',user_I='guest',password_I='guest',host_I="localhost:5432"'''
        engine = self.make_engineFromSettings(settings_I);
        self.Session = sessionmaker(bind=engine, class_=_Session);

    def set_session(self,database_I='sbaas01',user_I='guest',password_I='guest',host_I="localhost:5432"):
        '''set a session object '''
        engine = self.make_engine(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
        self.Session = sessionmaker(bind=engine, class_=_Session);

    def get_session(self):
        '''return new session object'''
        session = self.Session();
        return session; 

    def get_engine(self):
        '''return engine'''
        return self.engine; 

    def create_newDatabaseAndUserFromSettings(self,
            database_I='postgres',user_I='postgres',password_I='18dglass',host_I="localhost:5432",
            settings_I = {},
            privileges_O=['ALL PRIVILEGES'],tables_O=['ALL TABLES'],schema_O='public'):
        '''create a new database and user
        INPUT: settings to connect to an exiting database
        database_I
        user_I
        password_I
        host_I
        OUTPUT: settings for the new database and user
        database_O (in settings_I)
        user_O (in settings_I)
        password_O (in settings_I)
        privileges_O
        tables_O
        schema_O'''
        try:
            conn = self.make_connection(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
            self.create_database(conn,settings_I['database']);
            self.create_user(conn,settings_I['user'],settings_I['password'],privileges_O,tables_O,schema_O);
            conn.close();
        except SQLAlchemyError as e:
            print(e);
            exit(-1);

    def copy_databaseFromSettings(self,
            database_I='postgres',user_I='postgres',password_I='18dglass',host_I="localhost:5432",
            settings_I = {},
            database_O = 'postgres_copy'):
        '''copy a database'''
        return;

    def dump_databaseFromSettings(self,
            settings_I = {},
            database_dump_options_I = {},
            filename_O='database_dump'):
        '''backup a database'''
        return;

    def restore_databaseFromSettings(self,
            settings_I = {},
            database_dump_options_I = {},
            filename_O='database_dump'):
        '''restore a database'''
        return;

    def create_policy(self,conn,
            user_I='guest',
            privileges_I=['SELECT'],
            tables_I=['ALL TABLES'],
            schema_I='public',
            using_I="",
            with_check_I="",
            ):
        '''create table level policy
        INPUT:
        user_I = username
        privileges_I = list of priveleges (e.g., ['SELECT','UPDATE','DELETE','INSERT']
        tables_I = list of tables
        schema_I = string
        using_I = constraint for SELECT privilege
        with_check_ I = constraint for INSERT, UPDATE, DELETE privileges
        '''

        try:
            privileges = ', '.join(privileges_I);
            for table in tables_I:
                cmd = 'CREATE POLICY "%s"_"%s" ' %(user_I,table);
                cmd += 'ON "%s"."%s" ' %(schema_I,table);
                cmd += 'FOR %s TO "%s" ' %(privileges,user_I);
                if 'SELECT' in privileges_I:
                    cmd += "USING (%s) " %(using_I);
                if 'UPDATE' in privileges_I or 'DELETE' in privileges_I:
                    cmd += "WITH CHECK (%s) " %(using_I);
                cmd += ';';
                try:
                    conn.execute(cmd);
                    conn.execute("commit");
                except SQLAlchemyError as e:
                    print(e);
                    conn.rollback();
        except SQLAlchemyError as e:
            print(e);
            #conn.rollback();

    def alter_table_action(self,conn,
            action_I='ENABLE ROW LEVEL SECURITY',
            tables_I=['ALL TABLES'],
            schema_I='public',
            ):
        '''alter tables using the ALTER TABLE action format
        INPUT:
        action_I = string
        tables_I = list of tables
        schema_I = string
        '''

        try:
            for table in tables_I:
                cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,table);
                cmd += '%s ' %(action_I);
                cmd += ';';
                try:
                    conn.execute(cmd);
                    conn.execute("commit");
                except SQLAlchemyError as e:
                    print(e);
                    conn.rollback();
        except SQLAlchemyError as e:
            print(e);
            #conn.rollback();
