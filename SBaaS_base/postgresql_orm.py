from os import system
from .postgresql_orm_base import *
from .postgresql_utilities import _Session

def return_postgresqlQueryFromSQLAlchemyQuery(query_I):
    '''return a string representation of the actual postgresql query
    generated by SQLAlchemy
    INPUT:
    query_I = SQLAlchemy query object
    OUTPUT;
    query_O = string query
    '''
    query_O = str(query_I.statement.compile(dialect=postgresql.dialect()));
    #print(str(query_I.statement.compile(dialect=postgresql.dialect())));
    return query_O;

def execute_query(conn,
    cmd,
    verbose_I=False,
    execute_I=True,
    commit_I=True,
    return_response_I=False,
    return_cmd_I=False,
    ):
    '''
    execute a query
    INPUT:
    conn = session object
    cmd = string
    verbose_I = boolean, if True, cmd is printed to the screen
    execute_I = boolean, if True, cmd is executed
    commit_I = boolean, if True, executed cmd is committed,
    return_response_I = boolean, if True, response from the executed cmd is returned,
    return_cmd_I = boolean, if True, the cmd is returned
    '''

    if verbose_I: print(cmd);
    if execute_I:
        try:
            ans = conn.execute(cmd);
            if commit_I: conn.commit();
            if return_response_I: return ans;
        except SQLAlchemyError as e:
            print(e);
            conn.rollback();
    if return_cmd_I: return cmd;

class postgresql_orm():
    def __init__(self):
        self.engine = None;
        self.Session = None;

    def make_engineFromSettings(self,settings_I={}):
        '''make the database engine
        INPUT:
        settings_I = string dict, {settings name:settings value}
        '''
        engine = create_engine("postgresql://%s:%s@%s/%s" %
            (settings_I['user'], settings_I['password'], settings_I['host'], settings_I['database']))
        self.engine = engine;
        return engine;

    def make_engine(self,database_I='sbaas01',user_I='guest',password_I='guest',host_I="localhost:5432"):
        '''make the database engine'''
        engine = create_engine("postgresql://%s:%s@%s/%s" %
            (user_I, password_I, host_I, database_I))
        self.engine = engine;
        return engine;

    def make_defaultEngine(self):
        '''return default database engine'''
        engine = create_engine("postgres://postgres@/postgres");
        self.engine = engine;
        return engine;

    def make_connectionFromSettings(self,
            settings_I={}):
        '''return connection to the database
        INPUT (option1):
        settings_I
        '''
        try:
            engine = self.make_engineFromSettings(settings_I);
            conn = engine.connect();
            conn.execute("commit");
            return conn;
        except SQLAlchemyError as e:
            print(e);
            exit(-1);

    def make_connection(self,
            database_I='postgres',user_I='postgres',password_I='postgres',host_I="localhost:5432"):
        '''return connection to the database
        INPUT (option2):
        database_I
        user_I
        password_I
        host_I
        '''
        try:
            engine = self.make_engine(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
            conn = engine.connect();
            conn.execute("commit");
            return conn;
        except SQLAlchemyError as e:
            print(e);
            exit(-1);

    def create_newDatabaseAndUser(self,
            database_I='postgres',user_I='postgres',password_I='postgres',host_I="localhost:5432",
            database_O='sbaas01',user_O='guest',password_O='guest',privileges_O=['ALL PRIVILEGES'],tables_O=['ALL TABLES'],schema_O='public'):
        '''create a new database and user
        INPUT: settings to connect to an exiting database
        database_I
        user_I
        password_I
        host_I
        OUTPUT: settings for the new database and user
        database_O
        user_O
        password_O
        privileges_O
        tables_O
        schema_O'''
        try:
            conn = self.make_connection(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
            self.create_database(conn,database_O);
            self.create_user(conn,user_O,password_O);
            self.grant_privileges(conn,user_O,privileges_O,tables_O,schema_O);
            conn.close();
        except SQLAlchemyError as e:
            print(e);
            exit(-1);
    
    def create_database(self,conn,database_I='sbaas',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        """create a new database"""
        cmd = 'CREATE DATABASE "%s"' %(database_I);
        data = execute_query(conn,
            cmd,
            verbose_I=verbose_I,
            execute_I=execute_I,
            commit_I=commit_I,
            return_response_I=return_response_I,
            return_cmd_I=return_cmd_I,
            )
        if data: return data

    def drop_database(self,conn,database_I='sbaas',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        """drop a database"""
        cmd = 'DROP DATABASE IF EXISTS "%s"' %(database_I);
        data = execute_query(conn,
            cmd,
            verbose_I=verbose_I,
            execute_I=execute_I,
            commit_I=commit_I,
            return_response_I=return_response_I,
            return_cmd_I=return_cmd_I,
            )
        if data: return data

    def drop_user(self,conn,user_I,
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        """drop a user"""
        cmd = 'DROP USER IF EXISTS "%s"' %(user_I);
        data = execute_query(conn,
            cmd,
            verbose_I=verbose_I,
            execute_I=execute_I,
            commit_I=commit_I,
            return_response_I=return_response_I,
            return_cmd_I=return_cmd_I,
            )
        if data: return data

    def create_user(self,conn,user_I='guest',password_I='guest',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        '''create a new role with a password
        INPUT:
        user_I = username
        password_I = password'''

        cmd = 'CREATE USER "%s" ' %(user_I);
        cmd += "WITH PASSWORD '%s'" %(password_I);
        data = execute_query(conn,
            cmd,
            verbose_I=verbose_I,
            execute_I=execute_I,
            commit_I=commit_I,
            return_response_I=return_response_I,
            return_cmd_I=return_cmd_I,
            )
        if data: return data

    def grant_privileges(self,conn,user_I='guest',
            privileges_I=['SELECT'],
            tables_I=['ALL TABLES'],
            schemas_I=['public'],
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        '''grant privileges to user/role
        INPUT:
        user_I = username
        privileges_I = list of priveleges (e.g., ['SELECT','UPDATE','DELETE','INSERT']
        tables_I = list of tables
        schema_I = schema name
        '''

        try:
            privileges = ', '.join(privileges_I);
            tables = '';
            if type(schemas_I)==type(''):
                for i,table in enumerate(tables_I):
                    tables += ('"%s"."%s", '%(schemas_I,table));
            elif len(tables_I)==len(schemas_I):
                for i,table in enumerate(tables_I):
                    tables += ('"%s"."%s", '%(schemas_I[i],table));
            elif len(schemas_I)==1:
                for i,table in enumerate(tables_I):
                    tables += ('"%s"."%s", '%(schemas_I[0],table));
            tables = tables[:-2];
            #cmd = 'GRANT %s ON %s IN SCHEMA %s TO "%s"' %(privileges,tables,schema_I,user_I);
            cmd = 'GRANT %s ON %s TO "%s"' %(privileges,tables,user_I);
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def revoke_privileges(self,conn,user_I='guest',
            privileges_I=['SELECT'],
            tables_I=['ALL TABLES'],
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        '''grant privileges to user/role
        INPUT:
        user_I = username
        privileges_I = list of priveleges (e.g., ['SELECT','UPDATE','DELETE','INSERT']
        tables_I = list of tables
        schema_I = schema name,
        '''

        data_O = [];
        try:
            privileges = ', '.join(privileges_I);
            tables = ', '.join(tables_I);
            for table in tables_I:
                for privilege in privileges_I:
                    #cmd = 'REVOKE %s ON %s IN SCHEMA %s FROM "%s"' %(privilege,table,schema_I,user_I);
                    cmd = 'REVOKE %s ON "%s" FROM "%s"' %(privilege,table,user_I);
                    
                    data = execute_query(conn,
                        cmd,
                        verbose_I=verbose_I,
                        execute_I=execute_I,
                        commit_I=commit_I,
                        return_response_I=return_response_I,
                        return_cmd_I=return_cmd_I,
                        )
                    if data: data_O.append(data)
            if data_O: return data_O
        except SQLAlchemyError as e:
            print(e);

    def set_sessionFromSettings(self,settings_I):
        '''set a session object ,database_I='sbaas01',user_I='guest',password_I='guest',host_I="localhost:5432"'''
        engine = self.make_engineFromSettings(settings_I);
        self.Session = sessionmaker(bind=engine, class_=_Session);

    def set_session(self,database_I='sbaas01',user_I='guest',password_I='guest',host_I="localhost:5432"):
        '''set a session object '''
        engine = self.make_engine(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
        self.Session = sessionmaker(bind=engine, class_=_Session);

    def get_session(self):
        '''return new session object'''
        session = self.Session();
        return session; 

    def get_engine(self):
        '''return engine'''
        return self.engine; 

    def create_newDatabaseAndUserFromSettings(self,
            database_I='postgres',user_I='postgres',password_I='postgres',host_I="localhost:5432",
            settings_I = {},
            privileges_O=['ALL PRIVILEGES'],tables_O=['ALL TABLES'],schema_O='public'):
        '''create a new database and user
        INPUT: settings to connect to an exiting database
        database_I
        user_I
        password_I
        host_I
        OUTPUT: settings for the new database and user
        database_O (in settings_I)
        user_O (in settings_I)
        password_O (in settings_I)
        privileges_O
        tables_O
        schema_O'''
        try:
            conn = self.make_connection(database_I=database_I,user_I=user_I,password_I=password_I,host_I=host_I);
            self.create_database(conn,settings_I['database']);
            self.create_user(conn,settings_I['user'],settings_I['password'],privileges_O,tables_O,schema_O);
            self.grant_privileges(conn,settings_I['user'],privileges_O,tables_O,schema_O);
            conn.close();
        except SQLAlchemyError as e:
            print(e);
            exit(-1);

    def copy_databaseFromSettings(self,
            database_I='postgres',user_I='postgres',password_I='postgres',host_I="localhost:5432",
            settings_I = {},
            database_O = 'postgres_copy'):
        '''copy a database
        TODO:
        '''
        return;

    def dump_databaseFromSettings(self,
            settings_I = {},
            database_dump_options_I = {},
            filename_O='database_dump'):
        '''backup a database
        TODO:
        '''
        return;

    def replicate_databaseFromSettings(self,
            settings_I = {},
            database_dump_options_I = {},
            filename_O='database_dump'):
        '''backup a database
        TODO:
        '''
        return;

    def restore_databaseFromSettings(self,
            settings_I = {},
            database_dump_options_I = {},
            filename_O='database_dump'):
        '''restore a database
        TODO:
        '''
        return;

    def create_policy(self,conn,
            user_I='guest',
            privileges_I=['SELECT'],
            tables_I=['ALL TABLES'],
            schema_I='public',
            using_I="",
            with_check_I="",
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''create table level policy
        INPUT:
        user_I = username
        privileges_I = list of priveleges (e.g., ['SELECT','UPDATE','DELETE','INSERT']
        tables_I = list of tables
        schema_I = string
        using_I = constraint for SELECT privilege
        with_check_ I = constraint for INSERT, UPDATE, DELETE privileges
        '''
        data_O = [];
        try:
            privileges = ' '.join(privileges_I);
            for table in tables_I:
                for privilege in privileges_I:
                    cmd = 'CREATE POLICY "%s_%s" ' %(user_I,privilege);
                    cmd += 'ON "%s"."%s" ' %(schema_I,table);
                    cmd += 'FOR %s TO "%s" ' %(privilege,user_I);
                    if privilege in ['UPDATE','SELECT','DELETE','ALL']:
                        cmd += "USING (%s) " %(using_I);
                    if privilege in ['UPDATE','INSERT','ALL']:
                        cmd += "WITH CHECK (%s) " %(using_I);
                    cmd += ';';
                    data = execute_query(conn,
                        cmd,
                        verbose_I=verbose_I,
                        execute_I=execute_I,
                        commit_I=commit_I,
                        return_response_I=return_response_I,
                        return_cmd_I=return_cmd_I,
                        )
                    if data: data_O.append(data)
            if data_O: return data_O
        except SQLAlchemyError as e:
            print(e);

    def drop_policy(self,conn,
            user_I='guest',
            privileges_I=['SELECT'],
            tables_I=['ALL TABLES'],
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''create table level policy
        INPUT:
        user_I = username
        privileges_I = list of priveleges (e.g., ['SELECT','UPDATE','DELETE','INSERT']
        tables_I = list of tables
        schema_I = string
        '''

        try:
            privileges = ' '.join(privileges_I);
            for table in tables_I:
                for privilege in privileges_I:
                    cmd = 'DROP POLICY IF EXISTS "%s_%s" ' %(user_I,privilege);
                    cmd += 'ON "%s"."%s" ' %(schema_I,table);
                    cmd += ';';
                    execute_query(conn,
                        cmd,
                        verbose_I=verbose_I,
                        execute_I=execute_I,
                        commit_I=commit_I,
                        return_response_I=return_response_I,
                        return_cmd_I=return_cmd_I,
                        )   
        except SQLAlchemyError as e:
            print(e);            
    
    def create_sequence(self,conn,
            schema_I='',
            sequence_I='_id_seq',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        """create a new sequence"""
        cmd = 'CREATE SEQUENCE "%s"."%s"' %(schema_I,sequence_I);
        data = execute_query(conn,
            cmd,
            verbose_I=verbose_I,
            execute_I=execute_I,
            commit_I=commit_I,
            return_response_I=return_response_I,
            return_cmd_I=return_cmd_I,
            )
        if data: return data

    def drop_sequence(self,conn,
            schema_I='',
            sequence_I='_id_seq',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,):
        """drop a sequence"""
        cmd = 'DROP SEQUENCE IF EXISTS "%s"."%s"' %(schema_I,sequence_I);
        data = execute_query(conn,
            cmd,
            verbose_I=verbose_I,
            execute_I=execute_I,
            commit_I=commit_I,
            return_response_I=return_response_I,
            return_cmd_I=return_cmd_I,
            )
        if data: return data

    def alter_table_addConstraint(self,conn,
            constraint_name_I='',
            constraint_type_I='',
            constraint_columns_I=[],
            constraint_clause_I='',
            table_I='',
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the ADD CONSTRAINT format
        INPUT:
        constraint_name_I = string
        constraint_type_I = string, e.g., UNIQUE, PRIMARY KEY, etc,.
        constraint_columns_I = list of column names to apply the constraint
        table_I = string
        schema_I = string
        '''

        try:
            cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,table_I);
            cmd += 'ADD CONSTRAINT "%s" %s  ' %(constraint_name_I,constraint_type_I);
            columns_str = '(';
            if constraint_columns_I:
                for column in constraint_columns_I:
                    columns_str += ('"%s",'%(column));
                columns_str += columns_str[:-1];
            elif constraint_clause_I:
                columns_str+='%s'%(constraint_clause_I)
            columns_str += ')';
            cmd += columns_str;
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def alter_table_drop(self,conn,
            attribute_I='CONSTRAINT',
            attribute_name_I='',
            tables_I='',
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the DROP format

        INPUT:
        attribute_I = string, attribute to drop
        attribute_name_I = name of the attribute
        tables_I = string
        schema_I = string
        '''

        try:
            cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,tables_I);
            cmd += 'DROP %s "%s"' %(attribute_I,attribute_name_I);
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def alter_table_action(self,conn,
            action_I='ENABLE ROW LEVEL SECURITY',
            action_options_I='',
            tables_I=['ALL TABLES'],
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the ALTER TABLE action format
        INPUT:
        action_I = string
        tables_I = list of tables
        schema_I = string
        '''
        
        data_O = [];
        try:
            for table in tables_I:
                cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,table);
                cmd += '%s ' %(action_I);
                cmd += '%s ' %(action_options_I);
                cmd += ';';
                data = execute_query(conn,
                    cmd,
                    verbose_I=verbose_I,
                    execute_I=execute_I,
                    commit_I=commit_I,
                    return_response_I=return_response_I,
                    return_cmd_I=return_cmd_I,
                    )
                if data: data_O.append(data)
            if data_O: return data_O
        except SQLAlchemyError as e:
            print(e);

    def create_table(self,conn,
            table_I='',
            schema_I='public',
            initialize_pkey_I = True,
            table_constraints_I = [],
            table_constraints_options_I = [],
            like_sourceTable_schema_I = 'public',
            like_sourceTable_I = '',
            like_options_I = 'INCLUDING ALL',  
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''create table
        INPUT:
        tables_I = string
        schema_I = string
        initialize_pkey_I = boolean, initialize "id" as primary key
        table_constraints_I = [] of string, table constraints (TODO)
        table_constraints_options_I = [] of string, table constraint options (TODO)
        like_sourceTable_schema_I = string,
        like_sourceTable_I = string,
        like_options_I = string
        '''

        try:
            cmd = 'CREATE TABLE IF EXISTS "%s"."%s" ' %(schema_I,table_I);
            if initialize_pkey_I:
                cmd += '(id integer NOT NULL \n CONSTRAINT "%s_pkey" PRIMARY KEY (id))\n'%table_I;
            elif like_sourceTable_I:
                cmd += '(LIKE "%s"."%s" %s )\n'%(
                    like_sourceTable_schema_I,like_sourceTable_I,
                    like_options_I);
            else:
                cmd += '()\n';
            cmd += 'WITH (OIDS=FALSE);'
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def drop_table(self,conn,
            table_I='',
            schema_I='public',
            cascade_restrict_I='',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''drop table
        INPUT:
        tables_I = string
        schema_I = string
        '''

        try:
            cmd = 'DROP TABLE IF EXISTS "%s"."%s" ' %(schema_I,table_I);
            if cascade_restrict_I:
                cmd += '%s ' %(cascade_restrict_I);
            cmd += ';'
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def alter_table_addAttribute(self,conn,
            attribute_I='Column',
            attribute_name_I='',
            attribute_parameters_I = 'varchar(50)',
            table_I='',
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the ADD format

        INPUT:
        attribute_I = string, attribute to drop
        attribute_name_I = name of the attribute
        attribute_parameters_I = name of the attribute
        table_I = string
        schema_I = string
        '''

        try:
            cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,table_I);
            cmd += 'ADD %s "%s" %s' %(attribute_I,attribute_name_I,attribute_parameters_I);
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);
            #conn.rollback();

    def alter_table_alterAttribute(self,conn,
            attribute_I='Column',
            attribute_name_I='',
            attribute_parameters_I = 'varchar(50)',
            tables_I='',
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the alter format

        INPUT:
        attribute_I = string, attribute to drop
        attribute_name_I = name of the attribute
        attribute_parameters_I = name of the attribute
        tables_I = string
        schema_I = string
        '''

        try:
            cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,tables_I);
            cmd += 'ALTER %s "%s" %s' %(attribute_I,attribute_name_I,attribute_parameters_I);
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def alter_table_renameAttribute(self,conn,
            attribute_I='Column',
            attribute_name_I='',
            attribute_name_new_I = '',
            tables_I='',
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the alter format

        INPUT:
        attribute_I = string, attribute to drop
        attribute_name_I = name of the attribute
        attribute_name_new_I = new name of the attribute
        tables_I = string
        schema_I = string
        '''

        try:
            cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,tables_I);
            cmd += 'RENAME %s "%s" TO "%s"' %(attribute_I,attribute_name_I,attribute_name_new_I);
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def rename_table(self,conn,
            table_I='',
            table_new_I = '',
            schema_I='public',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''alter tables using the alter format

        INPUT:
        tables_I = string
        table_new_I = string
        schema_I = string
        '''

        try:
            cmd = 'ALTER TABLE IF EXISTS "%s"."%s" ' %(schema_I,table_I);
            cmd += 'RENAME TO "%s"."%s"' %(schema_I,table_new_I);
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def create_function(self,conn,
            schema_I='',
            function_I='',
            argmode_I='',
            argname_I='',
            argtype_I='',
            default_expr_I='',
            returns_rettype_I ='',
            returns_table_I ='',
            returns_table_column_name_I =[],
            returns_table_column_type_I =[],
            language_I = 'plpgsql',
            as_I = '',
            with_attributes_I=[],
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''create function using the CREATE OR REPLACE FUNCTION syntax

        INPUT:
        schema_I='',
        function_I='',
        argmode_I='',
        argname_I='',
        argtype_I='',
        default_expr_I='',
        returns_rettype_I ='',
        returns_table_I ='',
        returns_table_column_name_I =[],
        returns_table_column_type_I =[],
        language_I = '',
        as_I = '',
        with_attributes_I=[],
        '''

        try:
            cmd = 'CREATE OR REPLACE FUNCTION "%s"."%s" ( \n' %(schema_I,function_I);

            if argmode_I:
                cmd += '%s' %(argmode_I);
            elif argname_I:
                cmd += '%s' %(argname_I);
            elif argtype_I:
                cmd += '%s' %(argtype_I);
            elif default_expr_I: #need to check this
                cmd += '%s' %(default_expr_I);
            else:
                cmd += ') \n';

            if returns_rettype_I:
                cmd += 'RETURNS %s \n ' %(returns_rettype_I);
            elif returns_table_I:
                cmd += 'RETURNS TABLE (';
                for i in range(len(returns_table_column_name_I)):
                    cmd += "%s %s " %(returns_table_column_name_I[i],
                                      returns_table_column_type_I[i]);
                cmd += ') \n';

            if as_I:
                cmd += 'AS %s' %(as_I);
            if language_I:
                cmd += 'LANGUAGE %s' %(language_I);
                
            if with_attributes_I:
                cmd += 'WITH (';
                for i in range(len(with_attributes_I)):
                    cmd += "%s " %(with_attributes_I[i]);
                cmd += ') \n';

            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def drop_function(self,conn,
            schema_I='',
            function_I='',
            argmode_I='',
            argname_I='',
            argtype_I='',
            cascade_restrict_I='',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''drop function using the DROP FUNCTION syntax

        INPUT:
        schema_I='',
        function_I='',
        argmode_I='',
        argname_I='',
        argtype_I='',
        cascade_restrict_I=string , [ CASCADE | RESTRICT ],
        '''

        try:
            cmd = 'DROP FUNCTION IF EXISTS "%s"."%s" ( \n' %(schema_I,function_I);

            if argmode_I:
                cmd += '%s' %(argmode_I);
            elif argname_I:
                cmd += '%s' %(argname_I);
            elif argtype_I:
                cmd += '%s' %(argtype_I);
            else:
                cmd += ') \n';

            if cascade_restrict_I:
                cmd += '%s \n ' %(cascade_restrict_I);

            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def create_trigger(self,conn,
            trigger_I='',
            constraint_I='',
            before_after_insteadOf_I='BEFORE',
            event_I ='',
            schema_I='public',
            table_name_I = '',
            referenced_table_schema_I='public',
            referenced_table_name_I='',
            deferrable_clause_I ='',
            for_clause_I ='',
            when_conditions_I = [],
            function_name_I = '',
            function_arguments_I = '',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''create trigger using the CREATE [CONSTRAINT] TRIGGER syntax

        INPUT:
        trigger_I='',
        constraint_I='',
        before_after_insteadOf_I='BEFORE',
        event_I ='',
        schema_I='public',
        table_name_I = '',
        referenced_table_schema_I='public',
        referenced_table_name_I='',
        deferrable_clause_I ='',
        for_clause_I ='',
        when_conditions_I = [],
        function_name_I = '',        
        function_arguments_I = string, comma-separated list of arguments
        '''

        try:
            if constraint_I:
                cmd = 'CREATE CONSTRAINT TRIGGER "%s" \n' %(trigger_I);
                assert(before_after_insteadOf_I=='AFTER')
            else:
                cmd = 'CREATE TRIGGER "%s" \n' %(trigger_I);

            if before_after_insteadOf_I:
                cmd += '%s %s \n ' %(before_after_insteadOf_I,event_I);

            cmd += 'ON "%s"."%s" \n ' %(schema_I,
                                          table_name_I);
            if referenced_table_name_I:
                cmd += 'FROM "%s"."%s" \n ' %(referenced_table_schema_I,
                                          referenced_table_name_I);
            if deferrable_clause_I:
                cmd += '%s \n ' %(deferrable_clause_I);
            if for_clause_I:
                cmd += '%s \n ' %(for_clause_I);
            if when_conditions_I:
                cmd += 'WHEN (';
                for i in range(len(when_conditions_I)):
                    cmd += "%s %s " %(when_conditions_I[i]);
                cmd += ') \n';

            cmd += 'EXECUTE PROCEDURE "%s" (%s) ' %(function_name_I,function_arguments_I);
            cmd += ';';
            
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def drop_trigger(self,conn,
            #schema_I='',
            trigger_I='',
            referenced_table_schema_I='public',
            referenced_table_name_I='',
            cascade_restrict_I='',
            verbose_I = False,
            execute_I = True,
            commit_I=True,
            return_response_I=False,
            return_cmd_I=False,
            ):
        '''drop trigger using the DROP TRIGGER syntax

        INPUT:
        #schema_I='',
        trigger_I='',
        referenced_table_schema_I='public',
        referenced_table_name_I='',   
        cascade_restrict_I=string , [ CASCADE | RESTRICT ],
        '''

        try:
            cmd = 'DROP TRIGGER IF EXISTS "%s" \n' %(trigger_I);
            #triggers are not schema qualified
            #cmd = 'DROP TRIGGER IF EXISTS "%s"."%s" \n' %(schema_I,trigger_I);
            
            if referenced_table_name_I:
                cmd += 'ON "%s"."%s" \n ' %(referenced_table_schema_I,
                                          referenced_table_name_I);
                
            if cascade_restrict_I:
                cmd += '%s \n ' %(cascade_restrict_I);
            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except SQLAlchemyError as e:
            print(e);

    def make_definition(self,
        definition_I = ''
        ):
        '''Return a postgres definition block
        INPUT:
        '''
        cmd = '$$\n%s\n$$'%definition_I;
        return cmd;

    def make_script(self,
            lines_I = [],
        ):
        '''Return a postgres script
        INPUT:
        '''
        cmd = 'BEGIN \n';
        for line in lines_I:
            cmd += '\t%s;\n'%line
        cmd +='END;'
        return cmd;

    def copy_table(self,
        conn,
        schema_I,
        table_name_I,
        column_names_I = [],
        query_I = '',
        to_or_from_I='TO',
        filename_I='',
        program_cmd_I='',
        stdin_or_stdout_I='',
        with_I=['FORMAT'],
        with_options_I=['binary'],
        verbose_I = True,
        execute_I = True,
        commit_I=True,
        return_response_I=False,
        return_cmd_I=False,
        ):
        '''Copy a table to disk
        INPUT:
        conn,
        schema_I=string,
        table_I=string,
        filename_I=string,
        delimiter_I=string, e.g., ',',

        '''
        try:
            cmd='COPY ';
            if column_names_I:
                cmd += '''"%s"."%s" ''' %(
                    schema_I,table_name_I);
                cmd+='(';
                for c in column_names_I:
                    cmd+='"%s",'%(c);
                cmd=cmd[:-1];
                cmd+=') '
            elif query_I:
                cmd='COPY (%s) '%(query_I)
            else:
                cmd += '''"%s"."%s" ''' %(
                    schema_I,table_name_I);

            cmd += '\n %s '%(to_or_from_I);
            if filename_I:
                cmd+="'%s' "%(filename_I);
            elif program_cmd_I:
                cmd+="PROGRAM '%s' "%(program_cmd_I);
            elif stdin_or_stdout_I:
                cmd+="%s "%(stdin_or_stdout_I);

            if with_I:
                cmd+='\n WITH (';
                for i,c in enumerate(with_I):
                    if c in ['DELIMITER','NULL','QUOTE','ESCAPE','ENCODING']:
                        cmd+="%s '%s',"%(c,with_options_I[i]);
                    else:
                        cmd+="%s %s,"%(c,with_options_I[i]);
                cmd=cmd[:-1];
                cmd+=')'            


            cmd += ';';
            data = execute_query(conn,
                cmd,
                verbose_I=verbose_I,
                execute_I=execute_I,
                commit_I=commit_I,
                return_response_I=return_response_I,
                return_cmd_I=return_cmd_I,
                )
            if data: return data
        except Exception as e:
            print(e);

